/*****************************************************************************
				BhartiSim Simulator
------------------------------------------------------------------------------------------------------------

   Copyright [2010] [Indian Institute of Technology, Delhi]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
------------------------------------------------------------------------------------------------------------

	Contributors:  Prathmesh Kallurkar
 *****************************************************************************/

package emulatorinterface.translator.x86.objparser;


import emulatorinterface.DynamicInstruction;
import emulatorinterface.translator.x86.instruction.InstructionClass;
import emulatorinterface.translator.x86.instruction.InstructionClassTable;
import emulatorinterface.translator.x86.instruction.InstructionHandler;
import emulatorinterface.translator.x86.operand.OperandTranslator;
import emulatorinterface.translator.x86.registers.Registers;
import generic.InstructionList;
import generic.InstructionTable;
import generic.Operand;
import generic.PartialDecodedInstruction;
import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import misc.Error;
import misc.Numbers;

/**
 * Objparser class contains methods to parse a static executable file and to
 * determine the information of dynamic instructions. The x86 assembly code
 * generated by objdump utility is first parsed to obtain operation, source
 * operands and destination operand. The x86 CISC operations are broken down
 * into corresponding simpler micro-operations which follow load-store
 * architecture. We store the linear address of the instruction and the
 * corresponding micro-operations in a hash-table for faster access to
 * instruction information later on..
 * 
 * @author prathmesh
 */
public class ObjParser 
{
	public static long staticHandled=0;
	public static long staticNotHandled=0;
	
	public static long dynamicHandled=0;
	public static long dynamicNotHandled=0;
	
	public static long dynamicCISCs=0;
	public static long dynamicMicroOps=0;

	public static BufferedWriter microOpsWriter = null;
	/**
	* This method translates a static instruction to dynamic instruction.
	* It takes as arguments - instructionTable, instructionPointer and dynamic
	* Instruction information
	*/
	public static InstructionList translateInstruction(
			InstructionTable instructionTable, Long instructionPointer,
			DynamicInstruction dynamicInstruction) 
	{
		dynamicCISCs++;
		
		//System.out.print("\n\tip = " + Long.toHexString(instructionPointer) + "\n");
		
		// Get partial decoded instruction
		PartialDecodedInstruction partialDecodedInstruction;
		partialDecodedInstruction = instructionTable.getInstruction(instructionPointer);
		
		if(partialDecodedInstruction==null)
		{
			// Check if the instruction was partially decoded or not ??
			//System.out.print("\n\tNo partial decoded instruction for " + 
			//		Long.toHexString(instructionPointer) + "\n");
			
			dynamicNotHandled++;
			return null;
		}
		
		else if((partialDecodedInstruction.getInstructionClass()==InstructionClass.CONDITIONAL_MOVE) ||
				(partialDecodedInstruction.getInstructionClass()==InstructionClass.CONDITIONAL_SET) ||
				(partialDecodedInstruction.getInstructionClass()==InstructionClass.FLOATING_POINT_CONDITIONAL_MOVE) ||
				(partialDecodedInstruction.getInstructionClass()==InstructionClass.FLOATING_POINT_LOAD_CONTROL_WORD) ||
				(partialDecodedInstruction.getInstructionClass()==InstructionClass.FLOATING_POINT_STORE_CONTROL_WORD) ||
				(partialDecodedInstruction.getInstructionClass()==InstructionClass.INTERRUPT))
		{
			//For some instruction classes, the implementation must be reviewed.
			
			dynamicNotHandled++;
			return null;
		}
		
		else
		{
			//Handle the instruction.
			
			// Obtain a handler for this instruction
			InstructionHandler handler = InstructionClassTable.
					getInstructionClassHandler((InstructionClass) partialDecodedInstruction.getInstructionClass());

			// Handle the instruction
			InstructionList instructionList;
			instructionList = new InstructionList();
			
			// Append operand handling code
			instructionList.appendInstruction((InstructionList) partialDecodedInstruction.getInstructionList());
			
			// Fuse the dynamic and the static instruction
			instructionList.appendInstruction(handler.handle(partialDecodedInstruction.getOperand1(), 
					partialDecodedInstruction.getOperand2(),	partialDecodedInstruction.getOperand3(), dynamicInstruction));
			
			// Set the program counter for this bunch of instructions
			instructionList.setProgramCounter(instructionPointer);
			
			//debug print
			//System.out.print(String.format("%-180s", " ").replace(" ", "#") + "\n\n");
			//System.out.print("IP=" + instructionPointer);
			//printPartialDecodedInstruction(partialDecodedInstruction);
			//System.out.print(instructionList);
			try {ObjParser.microOpsWriter.write(instructionList.toString());}
			catch (IOException e) {e.printStackTrace();}
						
			dynamicHandled++;
			dynamicMicroOps += instructionList.length();
			return instructionList;
		}
	}

	/**
	* This method parses the object file, and creates a hash-table from the
	* static instructions.
	* @param executableFile
	* @return
	*/
	public static InstructionTable buildStaticInstructionTable(String executableFile) 
	{
		BufferedReader input;

		// Read the assembly code from the program using obj-dump utility
		input = readObjDumpOutput(executableFile);

		// Create a new hash table
		InstructionTable instructionTable;
		instructionTable = new InstructionTable();

		// Create a instruction class hash-table
		InstructionClassTable instructionClassTable;
		instructionClassTable = new InstructionClassTable();

		String line;
		Long linearAddress;
		String operation;
		String operand1, operand2, operand3;
		PartialDecodedInstruction partialDecodedInstruction;
		long lineNumber = 0;

		// Read from the obj-dump output
		while ((line = readNextLineOfObjDump(input)) != null) 
		{
			lineNumber++;

			if (!(isContainingAssemblyCode(line)))
				continue;

			String assemblyCodeTokens[] = tokenizeAssemblyCode(line);

			// read the assembly code tokens
			linearAddress = Numbers.hexToLong(assemblyCodeTokens[0]);
			operation = assemblyCodeTokens[1];
			operand1 = assemblyCodeTokens[2];
			operand2 = assemblyCodeTokens[3];
			operand3 = assemblyCodeTokens[4];


			// Riscify current instruction
			partialDecodedInstruction = createPartialDecodedInstruction(
					operation, operand1, operand2, operand3,
					instructionClassTable);
			
			if(partialDecodedInstruction!=null)
			{
				staticHandled++;
				instructionTable.addInstruction(linearAddress, partialDecodedInstruction);
				
				//debug print
				//printCodeDetails(linearAddress, operation, operand1, operand2, 
				//		operand3, lineNumber, partialDecodedInstruction);
			}
			else
			{
				staticNotHandled++;
			}
		}

		// close the buffered reader
		try {
			input.close();
		} catch (IOException ioe) {
			Error.showErrorAndExit("\n\tError in closing the buffered reader !!");
		}

		return instructionTable;
	}

	private static PartialDecodedInstruction createPartialDecodedInstruction(
			String operation, String operand1Str, String operand2Str,
			String operand3Str, InstructionClassTable instructionClassTable) 
	{
		InstructionClass instructionClass;
		instructionClass = InstructionClassTable.getInstructionClass(operation);
		
		// We are not handling any instruction prefix now.
		if(instructionClass==InstructionClass.INVALID || 
		   instructionClass==InstructionClass.LOCK ||
		   instructionClass==InstructionClass.REPEAT)
		{
			return null;
		}
		
		InstructionList microOps = new InstructionList();		
		Registers registers = new Registers();
		
		Operand operand1 = OperandTranslator.simplifyOperand(operand1Str,
				microOps, registers);
		Operand operand2 = OperandTranslator.simplifyOperand(operand2Str,
				microOps, registers);
		Operand operand3 = OperandTranslator.simplifyOperand(operand3Str,
				microOps, registers);
		
		return new PartialDecodedInstruction(instructionClass, 
				microOps, operand1, operand2, operand3);
	}

	// runs obj-dump utility on the executable file to obtain the assembly code.
	// The obj-dump output is then returned using a buffered reader.
	private static BufferedReader readObjDumpOutput(String executableFileName) {
		BufferedReader input = null;

		try {
			// Generate the command for obj-dump with required command line
			// arguments
			String command[] = { "objdump", "--disassemble", "-Mintel",
					"--prefix-addresses", executableFileName };
			Process p = Runtime.getRuntime().exec(command);

			// read the output of the process in a buffered reader
			input = new BufferedReader(
					new InputStreamReader(p.getInputStream()));
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in running objdump on the executable file !!");
		}

		return input;
	}

	// reads the next line of buffered reader "input"
	private static String readNextLineOfObjDump(BufferedReader input) {
		try {
			return (input.readLine());
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in reading from the buffered reader containing assembly code !!");
		}

		// we would never reach this statement
		return null;
	}

	// checks if the passed line of objdump output matches the output for an
	// assembly code.
	private static boolean isContainingAssemblyCode(String line) {
		// A valid assembly code line has following pattern
		// linear-address <referrence-address> opcode (operands)
		return line.matches("[0-9a-fA-F]+ <.*> [a-zA-Z]+.*");
	}

	// for a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static String[] tokenizeAssemblyCode(String line) {
		String linearAddress;
		String operation;
		String operand1, operand2, operand3;
		String operands;

		// Initialise all operands to null
		operands = operand1 = operand2 = operand3 = null;

		// Tokenize the line
		StringTokenizer lineTokenizer = new StringTokenizer(line);

		// Read the tokens into required variables
		linearAddress = lineTokenizer.nextToken();
		lineTokenizer.nextToken(); // skip the referred address
		operation = lineTokenizer.nextToken();
		if (lineTokenizer.hasMoreTokens())
			operands = lineTokenizer.nextToken();

		// If the operation has tokens, then break it further.
		if (operands != null) {
			// First join all the operand tokens
			while (lineTokenizer.hasMoreTokens())
				operands = operands + " " + lineTokenizer.nextToken();

			StringTokenizer operandTokenizer = new StringTokenizer(operands,
					",", false);

			if (operandTokenizer.hasMoreTokens())
				operand1 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand2 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand3 = operandTokenizer.nextToken();
		}

		return new String[] { linearAddress, operation, operand1, operand2,
				operand3 };
	}

	// prints the assembly code parameters for a particular instruction
	private static void printCodeDetails(Long linearAddress, String operation,
			String operand1, String operand2, String operand3, long lineNumber,
			PartialDecodedInstruction partialDecodedInstruction) {
		System.out.print("\n\n"
				+ String.format("%-180s", " ").replace(" ", "-")
				+ "\n\n"
				+ String.format("%-20s", "Line-number = " + lineNumber
						+ "\tLinear-address = " + linearAddress + "\n")
				+ String.format("%-20s", "Op = " + operation.toString())
				+ String.format("%-40s", "Op1 = " + operand1)
				+ String.format("%-40s", "Op2 = " + operand2)
				+ String.format("%-40s", "Op3 = " + operand3));

		printPartialDecodedInstruction(partialDecodedInstruction);
	}

	private static void printPartialDecodedInstruction(
			PartialDecodedInstruction partialDecodedInstruction) {
		System.out.print("\ninstructionClass = "
				+ partialDecodedInstruction.getInstructionClass()
				+ String.format("%-40s", "\toperand1 = "
						+ partialDecodedInstruction.getOperand1())
				+ String.format("%-40s", "\toperand2 = "
						+ partialDecodedInstruction.getOperand2())
				+ String.format("%-40s", "\toperand3 = "
						+ partialDecodedInstruction.getOperand3())
				+ "\ninstructionList = "
				+ partialDecodedInstruction.getInstructionList());
	}
}