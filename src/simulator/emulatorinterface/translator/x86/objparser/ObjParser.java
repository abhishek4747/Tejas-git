/*****************************************************************************
				Tejas Simulator
------------------------------------------------------------------------------------------------------------

   Copyright [2010] [Indian Institute of Technology, Delhi]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
------------------------------------------------------------------------------------------------------------

	Contributors:  Prathmesh Kallurkar
 *****************************************************************************/

package emulatorinterface.translator.x86.objparser;

import emulatorinterface.DynamicInstructionBuffer;
import emulatorinterface.Newmain;
import emulatorinterface.translator.InvalidInstructionException;
import emulatorinterface.translator.visaHandler.VisaHandler;
import emulatorinterface.translator.visaHandler.VisaHandlerSelector;
import emulatorinterface.translator.x86.instruction.InstructionClass;
import emulatorinterface.translator.x86.instruction.InstructionClassTable;
import emulatorinterface.translator.x86.instruction.InstructionHandler;
import emulatorinterface.translator.x86.operand.OperandTranslator;
import emulatorinterface.translator.x86.registers.Registers;
import generic.GenericCircularQueue;
import generic.Instruction;
import generic.InstructionArrayList;
import generic.InstructionLinkedList;
import generic.InstructionTable;
import generic.Operand;
import generic.PartialDecodedInstruction;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.StringTokenizer;
import misc.Error;
import misc.Numbers;

/**
 * Objparser class contains methods to parse a static executable file and to
 * determine the information of dynamic instructions. The x86 assembly code
 * generated by objdump utility is first parsed to obtain operation, source
 * operands and destination operand. The x86 CISC operations are broken down
 * into corresponding simpler micro-operations which follow load-store
 * architecture. We store the linear address of the instruction and the
 * corresponding micro-operations in a hash-table for faster access to
 * instruction information later on..
 * 
 * @author prathmesh
 */
public class ObjParser 
{
	public static long staticHandled = 0;
	public static long staticNotHandled = 0;
	
	public static long dynamicHandled = 0;
	public static long dynamicNotHandled = 0;
	
	private static InstructionTable instructionTable = null;
	private static InstructionArrayList instructionArrayList = null;
	
	/**
	* This method translates a static instruction to dynamic instruction.
	* It takes as arguments - instructionTable, instructionPointer and dynamic
	* Instruction information
	*/

	/**
	* This method parses the object file, and creates a hash-table from the
	* static instructions.
	* @param executableFile
	* @return
	*/
	public static void buildStaticInstructionTable(String executableFile) 
	{
		BufferedReader input;

		// Read the assembly code from the program using object-dump utility
		input = readObjDumpOutput(executableFile);

		// Create a new hash table
		instructionTable = new InstructionTable();

		// Create a instruction class hash-table
		InstructionClassTable instructionClassTable;
		instructionClassTable = new InstructionClassTable();

		String line;
		long instructionPointer;
		String instructionPrefix;
		String operation;
		String operand1, operand2, operand3;
		
		instructionArrayList = new InstructionArrayList();
		
		long lineNumber = 0;
		int microOpsIndex = 0;
		
		// Read from the obj-dump output
		while ((line = readNextLineOfObjDump(input)) != null) 
		{
			lineNumber++;

			if (!(isContainingAssemblyCode(line)))
				continue;

			String assemblyCodeTokens[] = tokenizeAssemblyCode(line);

			// read the assembly code tokens
			instructionPointer = Numbers.hexToLong(assemblyCodeTokens[0]);
			
			//initialize different parameters of an instruction.
			if(isInstructionPrefix(assemblyCodeTokens[1]))
			{
				instructionPrefix = assemblyCodeTokens[1];
				operation = assemblyCodeTokens[2];
				operand1 = assemblyCodeTokens[3];
				operand2 = assemblyCodeTokens[4];
				operand3 = null;
			}
			else
			{
				instructionPrefix = null;
				operation = assemblyCodeTokens[1];
				operand1 = assemblyCodeTokens[2];
				operand2 = assemblyCodeTokens[3];
				operand3 = assemblyCodeTokens[4];
			}
			

			// Riscify current instruction
			microOpsIndex = riscifyInstruction( instructionPointer, 
					instructionPrefix, operation, 
					operand1, operand2, operand3, 
					instructionClassTable, instructionArrayList);

			// add instruction's index into the hash-table
			instructionTable.addInstruction(instructionPointer, microOpsIndex);
		}

		// close the buffered reader
		try {input.close();}
		catch (IOException ioe) {Error.showErrorAndExit("\n\tError in closing the buffered reader !!");}
		
		//System.out.print("\n\tProgram statically parsed.\n");
		//System.out.print("\n\tIts microOps list ...\n");
		//instructionArrayList.printList();
	}

	private static int riscifyInstruction(
			long instructionPointer, String instructionPrefix, String operation, 
			String operand1Str, String operand2Str, String operand3Str, 
			InstructionClassTable instructionClassTable, InstructionArrayList instructionArrayList) 
	{
		int microOpsIndexBefore = instructionArrayList.length();
		
		try
		{
			//Determine the instruction class for this instruction
			InstructionClass instructionClass;
			instructionClass = InstructionClassTable.getInstructionClass(operation);
			
			// Simplify the operands
			Operand operand1, operand2, operand3;
			
			Registers.noOfIntTempRegs = 0;
			Registers.noOfFloatTempRegs = 0;
			
			operand1 = OperandTranslator.simplifyOperand(operand1Str, instructionArrayList);
			operand2 = OperandTranslator.simplifyOperand(operand2Str, instructionArrayList);
			operand3 = OperandTranslator.simplifyOperand(operand3Str, instructionArrayList);
			
			
			// Obtain a handler for this instruction
			InstructionHandler handler;
			handler = InstructionClassTable.getInstructionClassHandler(instructionClass);
			
			// Handle the instruction
			if(handler!=null)
			{
				handler.handle(instructionPointer, operand1, operand2, operand3, instructionArrayList);
			}
			
			//now set the ip of all converted instructions to instructionPointer
			for(int i=microOpsIndexBefore; i<instructionArrayList.length(); i++)
			{
				instructionArrayList.setCISCProgramCounter(i, instructionPointer);
				//FIXME : index in the array list - check ??
				instructionArrayList.setRISCProgramCounter(i, i);
			}
		}catch(InvalidInstructionException inInstrEx)
		{
			/*
			 * microOps created for this instruction are not valid 
			 * since the translation of the instruction did not 
			 * complete its execution.
			 */
			while(instructionArrayList.getListSize()
					!=microOpsIndexBefore)
			{
				instructionArrayList.removeLastInstr();
			}
		}
		
		return microOpsIndexBefore;
	}
	
	//return true if the string is a valid instruction prefix
	private static boolean isInstructionPrefix(String string)
	{
		if(string.matches("rep|repe|repne|repz|repnz|lock"))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	// runs obj-dump utility on the executable file to obtain the assembly code.
	// The obj-dump output is then returned using a buffered reader.
	private static BufferedReader readObjDumpOutput(String executableFileName) {
		BufferedReader input = null;

		try {
			// Generate the command for obj-dump with required command line
			// arguments
			String command[] = { "objdump", "--disassemble", "-Mintel",
					"--prefix-addresses", executableFileName };
			Process p = Runtime.getRuntime().exec(command);

			// read the output of the process in a buffered reader
			input = new BufferedReader(
					new InputStreamReader(p.getInputStream()));
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in running objdump on the executable file !!");
		}

		return input;
	}


	// reads the next line of buffered reader "input"
	private static String readNextLineOfObjDump(BufferedReader input) 
	{
		try 
		{
			return (input.readLine());
		} 
		catch (IOException ioe) 
		{
			Error.showErrorAndExit("\n\tError in reading from the buffered reader containing assembly code !!");
		}

		// we would never reach this statement
		return null;
	}

	// checks if the passed line of objdump output matches the output for an
	// assembly code.
	private static boolean isContainingAssemblyCode(String line) 
	{
		// A valid assembly code line has following pattern
		// linear-address <referrence-address> opcode (operands)
		return line.matches("[0-9a-fA-F]+ <.*> [a-zA-Z]+.*");
	}

	
	// for a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static String[] tokenizeAssemblyCode(String line) 
	{
		String linearAddress;
		String operation;
		String operand1, operand2, operand3;
		String operands;

		// Initialise all operands to null
		operands = operand1 = operand2 = operand3 = null;

		// Tokenize the line
		StringTokenizer lineTokenizer = new StringTokenizer(line);

		// Read the tokens into required variables
		linearAddress = lineTokenizer.nextToken();
		lineTokenizer.nextToken(); // skip the referred address
		operation = lineTokenizer.nextToken();
		if (lineTokenizer.hasMoreTokens())
			operands = lineTokenizer.nextToken();

		// If the operation has tokens, then break it further.
		if (operands != null) {
			// First join all the operand tokens
			while (lineTokenizer.hasMoreTokens())
				operands = operands + " " + lineTokenizer.nextToken();

			StringTokenizer operandTokenizer = new StringTokenizer(operands,
					",", false);

			if (operandTokenizer.hasMoreTokens())
				operand1 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand2 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand3 = operandTokenizer.nextToken();
		}

		return new String[] { linearAddress, operation, operand1, operand2,
				operand3 };
	}

	// prints the assembly code parameters for a particular instruction
	@SuppressWarnings("unused")
	private static void printCodeDetails(Long linearAddress, String operation,
			String operand1, String operand2, String operand3, long lineNumber,
			PartialDecodedInstruction partialDecodedInstruction) 
	{
		System.out.print("\n\n"
				+ String.format("%-180s", " ").replace(" ", "-")
				+ "\n\n"
				+ String.format("%-20s", "Line-number = " + lineNumber
						+ "\tLinear-address = " + linearAddress + "\n")
				+ String.format("%-20s", "Op = " + operation.toString())
				+ String.format("%-40s", "Op1 = " + operand1)
				+ String.format("%-40s", "Op2 = " + operand2)
				+ String.format("%-40s", "Op3 = " + operand3));

		printPartialDecodedInstruction(partialDecodedInstruction);
	}

	private static void printPartialDecodedInstruction(
			PartialDecodedInstruction partialDecodedInstruction) 
	{
		System.out.print("\ninstructionClass = "
				+ partialDecodedInstruction.getInstructionClass()
				+ String.format("%-40s", "\toperand1 = "
						+ partialDecodedInstruction.getOperand1())
				+ String.format("%-40s", "\toperand2 = "
						+ partialDecodedInstruction.getOperand2())
				+ String.format("%-40s", "\toperand3 = "
						+ partialDecodedInstruction.getOperand3())
				+ "\ninstructionList = "
				+ partialDecodedInstruction.getInstructionList());
	}
	
	private static void removeInstructionFromTail(GenericCircularQueue<Instruction> inputToPipeline, long instructionPointer) {
		
		Instruction removedInstruction;
		while( (inputToPipeline.isEmpty()== false) &&
			(inputToPipeline.peek(inputToPipeline.size()-1).getCISCProgramCounter()==instructionPointer))
		{
			removedInstruction = inputToPipeline.pop();
			try {
				Newmain.instructionPool.returnObject(removedInstruction);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}

	public static void translateInstruction(
			long startInstructionPointer,
			DynamicInstructionBuffer dynamicInstructionBuffer, GenericCircularQueue<Instruction> inputToPipeline)
	{
		int microOpIndex;

//		dynamicInstructionBuffer.printBuffer();
//		System.out.print("\tEntered translate instruction @ ip = " + Long.toHexString(startInstructionPointer) + "\n");
		
		// traverse dynamicInstruction Buffer to go to a known instruction
		while(true)
		{
			microOpIndex = instructionTable.getMicroOpIndex(startInstructionPointer);
			
			if(microOpIndex==-1)
			{
				/* startInstructionPointer was never a part of the executable parsed earlier.
				 * We do not probe further to find a known instruction in the dynamicInstruction
				 * buffer since it would not be worth the extra effort for such a small window of
				 * instructions */
				dynamicInstructionBuffer.clearBuffer();
				return;
			}
			
			else if(instructionArrayList.get(microOpIndex).getCISCProgramCounter()!=startInstructionPointer)
			{
				/* The startInstructionPointer was part of the executable file and hence is present in
				 * the hashTable. However, it has not been decoded yet. So, we gobble all the branch,
				 *  memRead and memWrite instructions belnging to it from the dynamicInstructionBuffer.
				 */
				dynamicInstructionBuffer.gobbleInstruction(startInstructionPointer);
				
				// go to the next microOpIndex and set startInstructionPointer = microOps ip.
				microOpIndex++;
				startInstructionPointer = instructionArrayList.get(microOpIndex).getCISCProgramCounter();
			}
			
			else
			{
				break;
			}
		}

		Instruction microOperation;
		VisaHandler visaHandler;
		int microOpIndexBefore;
		
		// main translate loop.
		while(true)
		{
			microOperation = instructionArrayList.get(microOpIndex); 
			if(microOperation==null)
			{break;}
			
			visaHandler = VisaHandlerSelector.selectHandler(microOperation.getOperationType());
			
			microOpIndexBefore = microOpIndex;     //store microOpIndex
			microOpIndex = visaHandler.handle(microOpIndex, instructionTable, microOperation, dynamicInstructionBuffer); //handle
			//Instruction newInstruction=new Instruction(instructionArrayList.get(microOpIndexBefore));
			Instruction newInstruction = null;
			try {
				newInstruction = Newmain.instructionPool.borrowObject();
			} catch (Exception e) {
				//TODO what if there are no more objects in the pool??
				e.printStackTrace();
			}
			newInstruction.copy(instructionArrayList.get(microOpIndexBefore));
			inputToPipeline.enqueue(newInstruction); //append microOp
			
			if(microOpIndex != -1)
			{
//				System.out.print("microOp(" + microOpIndex + ") : " + microOp + "\n");
			}
			else
			{
				removeInstructionFromTail(inputToPipeline, 
						instructionArrayList.get(microOpIndexBefore).getCISCProgramCounter());
				break;
			}
		}
		
		/* clear the dynamicInstructionBuffer */		
		dynamicInstructionBuffer.clearBuffer();
		
//		instructionLinkedList.printList();
		return;
	}
}