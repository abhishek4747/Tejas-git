/*****************************************************************************
				Tejas Simulator
------------------------------------------------------------------------------------------------------------

   Copyright [2010] [Indian Institute of Technology, Delhi]
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
------------------------------------------------------------------------------------------------------------

	Contributors:  Prathmesh Kallurkar
 *****************************************************************************/

package emulatorinterface.translator.x86.objparser;

import emulatorinterface.DynamicInstructionBuffer;
import emulatorinterface.communication.Encoding;
import emulatorinterface.communication.Packet;
import emulatorinterface.translator.InvalidInstructionException;
import emulatorinterface.translator.visaHandler.DynamicInstructionHandler;
import emulatorinterface.translator.visaHandler.VisaHandlerSelector;
import emulatorinterface.translator.x86.instruction.InstructionClass;
import emulatorinterface.translator.x86.instruction.InstructionClassTable;
import emulatorinterface.translator.x86.instruction.X86StaticInstructionHandler;
import emulatorinterface.translator.x86.operand.OperandTranslator;
import emulatorinterface.translator.x86.registers.Registers;
import emulatorinterface.translator.x86.registers.TempRegisterNum;
import generic.GenericCircularQueue;
import generic.Instruction;
import generic.InstructionList;
import generic.InstructionTable;
import generic.Operand;
import generic.PartialDecodedInstruction;
import generic.Statistics;
import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.ArrayList;
import java.util.StringTokenizer;
import config.EmulatorConfig;
import main.CustomObjectPool;
import misc.Error;
import misc.Numbers;

/**
 * Objparser class contains methods to parse a static executable file and to
 * determine the information of dynamic instructions. The x86 assembly code
 * generated by objdump utility is first parsed to obtain operation, source
 * operands and destination operand. The x86 CISC operations are broken down
 * into corresponding simpler micro-operations which follow load-store
 * architecture. We store the linear address of the instruction and the
 * corresponding micro-operations in a hash-table for faster access to
 * instruction information later on..
 * 
 * @author prathmesh
 */
public class ObjParser 
{
	private static InstructionTable ciscIPtoRiscIP = null;
	private static InstructionList staticMicroOpList = null;
	private static InstructionList threadMicroOpsList[] = null;
	
	public static void initializeThreadMicroOpsList(int maxApplicationThreads) {
		threadMicroOpsList = new InstructionList[maxApplicationThreads];
		
		for(int i=0; i<maxApplicationThreads; i++) {
			threadMicroOpsList[i] = new InstructionList(10000);
		}
	}
	
	/**
	* This method translates a static instruction to dynamic instruction.
	* It takes as arguments - instructionTable, instructionPointer and dynamic
	* Instruction information
	*/

	/**
	* This method parses the object file, and creates a hash-table from the
	* static instructions.
	* @param executableFile
	* @return
	*/
	public static void buildStaticInstructionTable(String executableFile) 
	{
		BufferedReader input;

		long noOfLines = noOfLines(executableFile);

		// Read the assembly code from the program using object-dump utility
		input = readObjDumpOutput(executableFile);

		// Create a new hash table
		ciscIPtoRiscIP = new InstructionTable((int)noOfLines);

		System.out.println("The executable has " + noOfLines + " assembly lines");
		
		String line;
		long instructionPointer;
		String instructionPrefix;
		String operation;
		String operand1, operand2, operand3;
		
		staticMicroOpList = new InstructionList((int)noOfLines*3);
		
		int microOpsIndex = 0;
		
		long handled = 0, notHandled = 0;
		
		// Read from the obj-dump output
		while ((line = readNextLineOfObjDump(input)) != null) 
		{
//			System.out.println("Number of lines = " + (handled+notHandled) + 
//					" and size of array-list = " + staticMicroOpList.getListSize());
			
			if (!(isContainingObjDumpAssemblyCode(line))) {
				continue;
			}

			String assemblyCodeTokens[] = tokenizeAssemblyCode(line);

			// read the assembly code tokens
			instructionPointer = Numbers.hexToLong(assemblyCodeTokens[0]);
			
			//initialize different parameters of an instruction.
			if(isInstructionPrefix(assemblyCodeTokens[1]))
			{
				instructionPrefix = assemblyCodeTokens[1];
				operation = assemblyCodeTokens[2];
				operand1 = assemblyCodeTokens[3];
				operand2 = assemblyCodeTokens[4];
				operand3 = null;
			}
			else
			{
				instructionPrefix = null;
				operation = assemblyCodeTokens[1];
				operand1 = assemblyCodeTokens[2];
				operand2 = assemblyCodeTokens[3];
				operand3 = assemblyCodeTokens[4];
			}
			
			// Riscify current instruction
			int microOpsIndexBefore = microOpsIndex;
			int numRicscInsn = riscifyInstruction( instructionPointer, 
					instructionPrefix, operation, 
					operand1, operand2, operand3, 
					staticMicroOpList);
			microOpsIndex += numRicscInsn;
			
			if(microOpsIndexBefore==microOpsIndex) {
				notHandled++;
			} else {
				handled++;
			}

			// add instruction's index into the hash-table
			ciscIPtoRiscIP.addInstruction(instructionPointer, microOpsIndexBefore);
		}
		
		System.out.println("Total number of assembly lines = " + (handled + notHandled)); 
		System.out.println("Total number of micro-operations = " + staticMicroOpList.length());

		// close the buffered reader
		try {input.close();}
		catch (IOException ioe) {Error.showErrorAndExit("\n\tError in closing the buffered reader !!");}

		Statistics.setStaticCoverage(((double)handled/(double)(handled+notHandled))*(double)100);
	}

	private static int riscifyInstruction(
			long instructionPointer, String instructionPrefix, String operation, 
			String operand1Str, String operand2Str, String operand3Str, 
			InstructionList instructionList) 
	{
		int microOpsIndexBefore = instructionList.length();
		
		try
		{
			//Determine the instruction class for this instruction
			InstructionClass instructionClass;
			instructionClass = InstructionClassTable.getInstructionClass(operation);
			
			// Simplify the operands
			Operand operand1, operand2, operand3;
			
//			Registers.noOfIntTempRegs = 0;
//			Registers.noOfFloatTempRegs = 0;
			
			TempRegisterNum tempRegisterNum = new TempRegisterNum();
			
			operand1 = OperandTranslator.simplifyOperand(operand1Str, instructionList, tempRegisterNum);
			operand2 = OperandTranslator.simplifyOperand(operand2Str, instructionList, tempRegisterNum);
			operand3 = OperandTranslator.simplifyOperand(operand3Str, instructionList, tempRegisterNum);
			
			// Obtain a handler for this instruction
			X86StaticInstructionHandler handler;
			handler = InstructionClassTable.getInstructionClassHandler(instructionClass);
			
			// Handle the instruction
			if(handler!=null)
			{
				handler.handle(instructionPointer, operand1, operand2, operand3, instructionList, tempRegisterNum);
			}
			
			//now set the ip of all converted instructions to instructionPointer
			for(int i=microOpsIndexBefore; i<instructionList.length(); i++)
			{
				instructionList.setCISCProgramCounter(i, instructionPointer);
				//FIXME : index in the array list - check ??
				instructionList.setRISCProgramCounter(i, i);
			}
		} catch(InvalidInstructionException inInstrEx) {
			/*
			 * microOps created for this instruction are not valid 
			 * since the translation of the instruction did not 
			 * complete its execution.
			 */
			
//			System.err.print("Unable to riscify instruction : ");
//			System.err.println("ip="+instructionPointer+"\toperation="+operation+"\top1="
//					+operand1Str+"\top2="+operand2Str+"\top3="+operand3Str);
			
			
			while(instructionList.getListSize()
					!=microOpsIndexBefore)
			{
				instructionList.removeLastInstr();
			}
		}
		
		return (instructionList.length()-microOpsIndexBefore);
	}
	
	//return true if the string is a valid instruction prefix
	private static boolean isInstructionPrefix(String string)
	{
		if(string.matches("rep|repe|repne|repz|repnz|lock"))
		{
			return true;
		}
		else
		{
			return false;
		}
	}

	// runs obj-dump utility on the executable file to obtain the assembly code.
	// The obj-dump output is then returned using a buffered reader.
	private static BufferedReader readObjDumpOutput(String executableFileName) {
		BufferedReader input = null;

		try {
			// Generate the command for obj-dump with required command line
			// arguments
			String command[] = { "objdump", "--disassemble", "-Mintel",
					"--prefix-addresses", executableFileName };
			Process p = Runtime.getRuntime().exec(command);

			// read the output of the process in a buffered reader
			input = new BufferedReader(
					new InputStreamReader(p.getInputStream()));
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in running objdump on the executable file !!");
		}

		return input;
	}
	
	// Counts number of lines in a file.
	private static long noOfLines(String executableFileName) {
		long numLines = 0;
		BufferedReader input = null;

		try {
			// Generate the command for obj-dump with required command line
			// arguments
			String command[] = { "objdump", "--disassemble", "-Mintel",
					"--prefix-addresses", executableFileName };
			Process p = Runtime.getRuntime().exec(command);

			// read the output of the process in a buffered reader
			input = new BufferedReader(
					new InputStreamReader(p.getInputStream()));
			
			while((input.readLine())!=null) {
				numLines++;
			}
		} catch (IOException ioe) {
			Error
					.showErrorAndExit("\n\tError in running objdump on the executable file !!");
		}

		return numLines;
	}


	// reads the next line of buffered reader "input"
	private static String readNextLineOfObjDump(BufferedReader input) 
	{
		try 
		{
			return (input.readLine());
		} 
		catch (IOException ioe) 
		{
			Error.showErrorAndExit("\n\tError in reading from the buffered reader containing assembly code !!");
		}

		// we would never reach this statement
		return null;
	}

	// checks if the passed line of objdump output matches the output for an
	// assembly code.
	private static boolean isContainingObjDumpAssemblyCode(String line) 
	{
		// A valid assembly code line has following pattern
		// linear-address <referrence-address> opcode (operands)
		return line.matches("[0-9a-fA-F]+ <.*> [a-zA-Z]+.*");
	}

	
	// for a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static String[] tokenizeAssemblyCode(String line) 
	{
		String linearAddress;
		String operation;
		String operand1, operand2, operand3;
		String operands;
		
		// remove the suffix part of string 
		if(line.indexOf("#")!=-1) {
			line = line.substring(0, line.indexOf("#"));
		}
		
		// remove the part of string enclosed in <...>
		line.replaceAll("<.*>", "");

		// Initialise all operands to null
		operands = operand1 = operand2 = operand3 = null;

		// Tokenize the line
		StringTokenizer lineTokenizer = new StringTokenizer(line);

		// Read the tokens into required variables
		linearAddress = lineTokenizer.nextToken();
		lineTokenizer.nextToken(); // skip the referred address
		operation = lineTokenizer.nextToken();
		if (lineTokenizer.hasMoreTokens())
			operands = lineTokenizer.nextToken();

		// If the operation has tokens, then break it further.
		if (operands != null) {
			// First join all the operand tokens
			while (lineTokenizer.hasMoreTokens())
				operands = operands + " " + lineTokenizer.nextToken();

			StringTokenizer operandTokenizer = new StringTokenizer(operands,
					",", false);

			if (operandTokenizer.hasMoreTokens())
				operand1 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand2 = operandTokenizer.nextToken();
			if (operandTokenizer.hasMoreTokens())
				operand3 = operandTokenizer.nextToken();
		}

		return new String[] { linearAddress, operation, operand1, operand2,
				operand3 };
	}
	
	// for  a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static String[] tokenizeQemuAssemblyCodeSS(String line) 
	{
		String instructionPrefix;
		String operation;
		String operand1, operand2, operand3;
		String operands;

		// Initialise all operands to null
		instructionPrefix = operation = null; 
		operands = operand1 = operand2 = operand3 = null;

		// Tokenize the line
		StringTokenizer lineTokenizer = new StringTokenizer(line);

		// Read the tokens into required variables
		String str = lineTokenizer.nextToken().trim();
		if(isInstructionPrefix(str)==true) {
			instructionPrefix = str;
			operation = lineTokenizer.nextToken().trim();
		} else {
			instructionPrefix = null;
			operation = str;
		}
		
		if (lineTokenizer.hasMoreTokens()) {
			operands = lineTokenizer.nextToken();
		
			// First join all the operand tokens
			while (lineTokenizer.hasMoreTokens()) {
				operands = operands + " " + lineTokenizer.nextToken();
			}

			StringTokenizer operandTokenizer = new StringTokenizer(operands,
					",", false);

			if (operandTokenizer.hasMoreTokens()) {
				operand1 = operandTokenizer.nextToken().trim();
			}
			
			if (operandTokenizer.hasMoreTokens()) {
				operand2 = operandTokenizer.nextToken().trim();
			}
			
			if (operandTokenizer.hasMoreTokens()) {
				operand3 = operandTokenizer.nextToken().trim();
			}
		}

		return new String[] { instructionPrefix, operation, operand1, operand2, operand3 };
	}
	
	// return index of null character for a byte array
	private static int len(byte[] asmBytes) {
		int i=0;
		for(;asmBytes[i]!=0 && i<asmBytes.length;i++);
		return i;
	}
	
	// searches character ch in asmByes. If not-found return -1, else return index of ch
	private static int indexOf(byte[] asmBytes, char ch, int offset, int len) {
		for(int i=offset; i<len(asmBytes); i++) {
			if(asmBytes[i]==ch) {
				return i;
			}
		}
		
		return -1;
	}
	
	// for  a line of assembly code, this would return the
	// linear address, operation, operand1,operand2, operand3
	private static void tokenizeQemuAssemblyCode(byte[] asmBytes, 
		String instructionPrefix, String operation,
		String operand1, String operand2, String operand3 ) {
		
		System.out.println("assembly = " + new String(asmBytes));
		
		int previousPointer, currentPointer;
		previousPointer = currentPointer = 0;

		// -------------- instructionPrefix and operation ---------------------------------- 
		currentPointer = indexOf(asmBytes, ' ', previousPointer, 64);
		
		if(currentPointer==-1) {
			instructionPrefix = null;
			operation = new String(asmBytes, 0, len(asmBytes));
			operand1 = operand2 = operand3 = null;
			return;
		}
		
		String str = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
		currentPointer++; previousPointer = currentPointer;
		
		if(isInstructionPrefix(str)) {
			instructionPrefix = str;
			currentPointer = indexOf(asmBytes, ' ', previousPointer, 64);
			
			operation = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
			currentPointer++; previousPointer = currentPointer;
		} else {
			instructionPrefix = null;
			operation = str;
		}
		
		// --------------------- operand1, operand2, operand3 --------------------------------
		if(previousPointer==len(asmBytes)) {
			operand1 = operand2 = operand3 = null;
			return;
		}
		
		currentPointer = indexOf(asmBytes, ',', previousPointer, 64);
		if(currentPointer==-1) {
			operand2 = operand3 = null;
			operand1 = new String(asmBytes, previousPointer, len(asmBytes)-previousPointer);
			return;
		} else {
			operand1 = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
			currentPointer+=2; previousPointer=currentPointer;
			
			if(previousPointer==len(asmBytes)) {
				operand2 = operand3 = null;
			} else {
				currentPointer = indexOf(asmBytes, ',', previousPointer, 64);
				
				if(currentPointer==-1) {
					operand3 = null;
					operand2 = new String(asmBytes, previousPointer, len(asmBytes)-previousPointer);
					return;
				} else {
					operand2 = new String(asmBytes, previousPointer, (currentPointer-previousPointer));
					currentPointer++; previousPointer=currentPointer;
					
					operand3 = new String(asmBytes, previousPointer, len(asmBytes)-previousPointer);
					return;
				}
			}
		}
	} 
	

	// prints the assembly code parameters for a particular instruction
	@SuppressWarnings("unused")
	private static void printCodeDetails(Long linearAddress, String operation,
			String operand1, String operand2, String operand3, long lineNumber,
			PartialDecodedInstruction partialDecodedInstruction) 
	{
		System.out.print("\n\n"
				+ String.format("%-180s", " ").replace(" ", "-")
				+ "\n\n"
				+ String.format("%-20s", "Line-number = " + lineNumber
						+ "\tLinear-address = " + linearAddress + "\n")
				+ String.format("%-20s", "Op = " + operation.toString())
				+ String.format("%-40s", "Op1 = " + operand1)
				+ String.format("%-40s", "Op2 = " + operand2)
				+ String.format("%-40s", "Op3 = " + operand3));

		printPartialDecodedInstruction(partialDecodedInstruction);
	}

	private static void printPartialDecodedInstruction(
			PartialDecodedInstruction partialDecodedInstruction) 
	{
		System.out.print("\ninstructionClass = "
				+ partialDecodedInstruction.getInstructionClass()
				+ String.format("%-40s", "\toperand1 = "
						+ partialDecodedInstruction.getOperand1())
				+ String.format("%-40s", "\toperand2 = "
						+ partialDecodedInstruction.getOperand2())
				+ String.format("%-40s", "\toperand3 = "
						+ partialDecodedInstruction.getOperand3())
				+ "\ninstructionList = "
				+ partialDecodedInstruction.getInstructionList());
	}
	
	private static boolean removeInstructionFromTail(GenericCircularQueue<Instruction> inputToPipeline, long instructionPointer) {
		
		Instruction removedInstruction;
		boolean foundThisCISC = false;
		
		while( (inputToPipeline.isEmpty()== false) &&
			(inputToPipeline.peek(inputToPipeline.size()-1).getCISCProgramCounter()==instructionPointer))
		{
			foundThisCISC = true;
			removedInstruction = inputToPipeline.pop();
			try {
				CustomObjectPool.getInstructionPool().returnObject(removedInstruction);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		return foundThisCISC;
	}

	/*
	 * This function fuses the statically translated micro-ops with the information received from the emulator.
	 * New micro-ops are added to the circular buffer(argument). Finally it returns the number of CISC instructions it could 
	 * translate.
	 */
	public static int fuseInstruction(
			int tidApp, long startInstructionPointer,
			ArrayList<Packet> arrayListPacket, GenericCircularQueue<Instruction> inputToPipeline)
	{		
//		if(true) {
//			return 0;
//		}
		
		// Create a dynamic instruction buffer for all control packets
		DynamicInstructionBuffer dynamicInstructionBuffer = new DynamicInstructionBuffer();
		dynamicInstructionBuffer.configurePackets(arrayListPacket);
		
		InstructionList assemblyPacketList = null;
		
		int numCISC = 0;
		int microOpIndex = 0;
		
		// Riscify the assembly packets
		if(EmulatorConfig.EmulatorType==EmulatorConfig.EMULATOR_QEMU) {
			for (int i = 0; i < arrayListPacket.size(); i++) 
			{
				assemblyPacketList = threadMicroOpsList[tidApp]; 
				Packet p = arrayListPacket.get(i);
				
				if(p.value==Encoding.ASSEMBLY) {
					byte asmBytes[] = CustomObjectPool.getCustomAsmCharPool().pop(tidApp);
					
					// System.out.println(i + " : " + assemblyLine);
					long instructionPointer = p.ip;
					String instructionPrefix = null, operation = null;
					String operand1 = null, operand2 = null, operand3 = null;
					
					tokenizeQemuAssemblyCode(asmBytes, instructionPrefix, operation,
						operand1, operand2, operand3);
					
					riscifyInstruction( instructionPointer, 
						instructionPrefix, operation, 
						operand1, operand2, operand3, 
						assemblyPacketList);
				}
			}
		} else if (EmulatorConfig.EmulatorType==EmulatorConfig.EMULATOR_PIN) {
			assemblyPacketList = staticMicroOpList;
			
			// traverse dynamicInstruction Buffer to go to a known instruction
			while(true)
			{
				microOpIndex = ciscIPtoRiscIP.getMicroOpIndex(startInstructionPointer);
				
				if(microOpIndex==-1)
				{
					/* startInstructionPointer was never a part of the executable parsed earlier.
					 * We do not probe further to find a known instruction in the dynamicInstruction
					 * buffer since it would not be worth the extra effort for such a small window of
					 * instructions */
					dynamicInstructionBuffer.clearBuffer();
					return numCISC;
				}
				
				else if(assemblyPacketList.get(microOpIndex).getCISCProgramCounter()!=startInstructionPointer)
				{
					/* The startInstructionPointer was part of the executable file and hence is present in
					 * the hashTable. However, it has not been decoded yet. So, we gobble all the branch,
					 *  memRead and memWrite instructions belnging to it from the dynamicInstructionBuffer.
					 */
					dynamicInstructionBuffer.gobbleInstruction(startInstructionPointer);
					
					// go to the next microOpIndex and set startInstructionPointer = microOps ip.
					//FIXME : Why was this required ?? -> microOpIndex++;
					startInstructionPointer = assemblyPacketList.get(microOpIndex).getCISCProgramCounter();
				}
				
				else
				{
					break;
				}
			}

		}
		
		Instruction staticMicroOp;
		DynamicInstructionHandler dynamicInstructionHandler;
		long previousCISCIP;
		
		
		// starting
		previousCISCIP = -1;
		
		// main translate loop.
		while(true)
		{
			staticMicroOp = assemblyPacketList.get(microOpIndex); 
			if(staticMicroOp==null) {
				break;
			}
			
			dynamicInstructionHandler = VisaHandlerSelector.selectHandler(staticMicroOp.getOperationType());
			
			Instruction dynamicMicroOp = null;
			try {
				dynamicMicroOp = CustomObjectPool.getInstructionPool().borrowObject();
			} catch (Exception e) {
				System.err.println("Instruction pool is empty !!");
				e.printStackTrace();
				System.exit(1);
			}
			
			dynamicMicroOp.copy(assemblyPacketList.get(microOpIndex));
			microOpIndex = dynamicInstructionHandler.handle(microOpIndex, ciscIPtoRiscIP, dynamicMicroOp, dynamicInstructionBuffer); //handle
			
			if(microOpIndex==-1) {
				// I was unable to fuse certain micro-ops of this instruction. So, I must remove any previously 
				// computed micro-ops from the buffer
				CustomObjectPool.getInstructionPool().returnObject(dynamicMicroOp);
				if(removeInstructionFromTail(inputToPipeline, staticMicroOp.getCISCProgramCounter())==true) {
					numCISC--;
				}
				break;
			} else {

				if(staticMicroOp.getCISCProgramCounter()!=previousCISCIP) {
					previousCISCIP = staticMicroOp.getCISCProgramCounter();
					//System.out.println("#### "+ Long.toHexString(previousCISCIP));
					numCISC++;
				}
				
				inputToPipeline.enqueue(dynamicMicroOp); //append microOp
			}
		}
		
		/* clear the dynamicInstructionBuffer */		
		dynamicInstructionBuffer.clearBuffer();
		//System.out.println(inputToPipeline);
		return numCISC;
	}
}